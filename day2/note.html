<!DOCTYPE html>
<html lang="en">

<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta http-equiv="X-UA-Compatible" content="ie=edge">
     <title>Document</title>
</head>

<body>
     <button>a</button>
     <button>b</button>
     <button>c</button>
     <script>
          /*
          作用域（scope）
               js的运行的范围
          当打开浏览器的时候，解读到script标签的时候，会把js运行在一个window的全局作用域下（整个window下的环境都叫全局作用域）
          一个变量或者一个函数，默认属于window

          在运行函数的时候，函数内部会开辟一个执行栈，在执行栈中会创建一个活动变量的对象，会把函数中所有变量、函数存储到这个活动变量下，执行栈去运行这个活动变量，这些活动变量下的变量、函数只会作用在函数内
          这种现象就叫（局部作用域）
     */
          /* console.log(window.a);//如果没有使用var声明变量，再赋值之前是不会把a挂在window上的，所以a是找不到 undefined
               var a =10;
               console.log(a);//10
                */
          /*
          变量提升（预解析机制）：
               当浏览器去解析js的时候，会提前解析全局的变量或者函数的过程
               第一步：
               上来就找var 和 function
               第二部：
                    逐步解读代码，此时var和function就不用再去读了，一般读的是赋值，计算，输出，判断

               一个匿名函数自执行函数，如果带名字，在函数体内不管如何赋值同名的变量，结果都等于这个又名函数
          */
          /*           var a = 10;
                    (function a() {
                         a = {};
                         console.log(a);
                    })(); */
          /*    fn()
                  函数调用的时候，开辟一个栈内存 
                       1.形参赋值
                       2.变量提升
                       3.执行上下文
                       4.执行栈销毁（变量和参数）
                  */
          /*  function fn(a) {
                console.log(a); //function a(){}
                var a =20;
                function a(){}
           }
           fn(function(){}) */
          /*   var a = 12;
            function fn(){
                 console.log(a); //undefined
                 return 12;
                 var a =11;
                 
            }
            fn(); */
          /*
               函数就是一个闭包， 闭包 函数可以使用函数之外定义的变量

               内部函数的作用域链仍然保持着对父函数活动对象的引用，就是闭包（closure）
               函数嵌套函数
               子函数引用父函数的参数或者变量，并且子函数还被外界所引用，这个时候子函数的作用域链仍然保持着对父函数活动对象的引用，父函数的参数和变量就不会被浏览器垃圾回收机制给回收，此时打印父函数的函数返回值，会发现在返回值下面有一个scopes，这个scopes线面有个closure，他就是闭包（整个父级都形成了闭包环境）

               全局的活动对象在关闭浏览器之后才会被销毁
          */

          /*         function fn() {
                       var a = 10;

                       function fn2() {
                            a++;
                            console.log(a);
                       }
                       return fn2
                  }
                  var s = fn();
                  // console.dir(s);
                  s();
                  s()
                  s() */

          /*     let btns = document.querySelectorAll('button');
              
              for(var i=0;i<btns.length;i++){
                   (function(i){
                        btns[i].onclick =function(){
                             alert(i);
                        }
                   })(i)
              } */

          /*
          var 变量提升，存入到全局的活动变量对象中，允许有多个同名的变量，不支持块级作用域

          let 不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
          不会存入到全局的活动变量对象中
          不允许有多个同名的变量
          支持块级作用域

          const 常量
               不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
               不会存入到全局的活动变量对象中
               不允许有多个同名的变量
               值是不能被改变的（引用类型可以改变属性值）
               声明了必须赋值
          */
          /* 
                    报错：
                    let a =10;
                    let a =20;  

                    var a =10;
                    var a =12;
                    a为12；
                    */


          /*
          解决重命名问题一（封闭空间）也有人看到匿名函数自执行就成为闭包
               函数天生就有局部作用域，函数内的变量、函数或者参数不被外界污染就形成了一个天然的保护层，不会被全局污染

          每个引用类型的地址是不一样的，在不一样的地址下挂同名属性访问的时候，虽然属性名一样，但是空间地址不一样，也能解决重命名的问题（命名空间）
          */
          let obj = {
               a: function () {
               console.log(1)
               }
          }

          let obj2 = {
               a: function () {
               console.log(2)
               }
          }
          obj.a();//1
          obj2.a();//2
     </script>
</body>

</html>