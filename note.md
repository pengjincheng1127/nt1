# 第一天
### git与github

> git 版本控制工具



SVN：集中式
    弊端:版本控制必须需要网络支持，一般SVN都是局域网，只能是公司内部人员使用，外界的人想参与开发是比较麻烦的，中央服务器不一定就稳定，一旦出事中央服务器所有资源都洗白白。

GIT：分布式
    不需要网络支持就能进行版本控制，只要能上网还要有开发权限都能参与开发，就算远程仓库库出事儿，计算机已经有了历史记录

GITHUB：程序员交友网站、远程仓库、帮助学习


> git的三大区域

- 工作区 （本地）

- 暂存区 （保护工作区和版本区）

- 版本区 （版本库、历史区）只有行成版本才能进行版本的控制


- 形成版本就是根据.git文件来操作的，所以说要进行版本控制，必须要有.git这个隐藏文件

- 按着tab键可以补全命令

- 设置用户信息:

git config --global user.name 'xxx'
git config --global user.eamil 'xxx'

- 创建版本仓库
    git init(想在哪进行版本控制，就在哪个文件夹下使用右键点击git bash here)


- 查看状态
    - git status

    如果查看状态的时候发现文件是红色的，就说明文件没有进行版本控制

- 工作区到暂存区
    - git add 文件名
    - git add .  (快速把所有文件都放到暂存区)


- 暂存区到版本区
    - git commit -m "取个自己能够识别的名字"


- 快速从工作区到版本区
    - git commit -a -m "取个自己能够识别的名字"

- 查看版本
    - git log
    - git reflog (查看所有的历史记录（包括历史区回滚后）)

出现nothing to commit, working directory clean就说明没有文件没被管理了（都被管理了）


- 回滚
    git reset --hard 历史ID


- touch .gitignore (创建.gitignore文件)

在文件中填写过滤的文件或文件夹

*.zip、*.rar、*.via、*.tmp过滤这些后缀名的文件

排除指定文件夹下的文件， /txt/1.txt

排除指定文件夹  \txt2

git rm -r --cached .  如果已经提交过的代码，使用.gitignore是无效的，那么请使用前面这段代码


- clear清屏

- 如果发现:号就按Q键退出

- 查看各大区域的区别
    - 工作区到暂存区  git diff
    - 工作区到版本区  git diff master
    - 暂存区到版本区  git diff --cached


- 把本地git的版本上传到github上管理

    - 设置秘钥:
        ssh-keygen -t rsa -C "your_email@example.com"

    - 登录github，右边头像下拉列表有个settings，找到SSH and GPG keys，找到new ssh key点击，把秘钥放到文本框中，点击add ssh key。

    - 在github上创建一个项目
        - 加号下拉列表，第一个创建新项目
        - 仓库名称
        - 说明
        - 公开
        - README打钩

- 查看远程仓库
    - git remote -v   
- 创建远程仓库
    - git remote add origin 远程地址
    ```
       比如: git remote add origin git@github.com:nizp/2019-10-8.git
    ```

- 同步远程
    - git pull origin master

- 推送到远程
    - git push origin(远程名字) master(分支名)
    ```
        比如:git push origin master
    ```
- 删除远程仓库
    - git remote remove 远程名字


- 克隆项目
    - 找到远程仓库的地址，git clone远程仓库地址 回车



### node的安装（自带就有npm）

- 项目的初始化
    - npm init -y
- npm install 安装程序

- npm uninstall 删除安装程序

- npm 目前是全球最大的包管理平台（里面有很多的代码资源）

npm install nrm -g

- 测nrm的速度  
    - nrm test
- 切换资源路线
    - nrm use taobao

- yarn的安装
    - npm install yarn -g

    - yarn add 安装程序
    - yarn remove 要删除的程序

# 第二天

## 作用域（scope）
    运行js的范围

    当打开浏览器的时候，解读到script标签的时候，会把js运行在一个window的全局作用域下（整个window下的环境都叫全局作用域）
    一个变量或者一个函数，默认属于window
    
    在运行函数的时候，函数内部会开辟一个执行栈，在执行栈中会创建一个活动变量的对象，会把函数中所有的变量、函数存储到这个活动变量下，执行栈去运行这个活动变量，这些活动变量下的变量、函数只会作用在函数内，这种现象就叫（局部作用域）

    作用域链：
        如果函数内访问不到某个变量，先去参数中找，还找不到会向父级函数查找，直到window全局，如果还找不到就报错


    局部作用域运行： 
        1.没有形参的时候，但是有var 如果在var的上方访问这个变量，结果是undefined
        2.有形参并且也有实参也有var ，如果在var的上方访问这个变量，结果应该是实参
        3.如果函数内有函数，有形参并且也有实参，那么结果就为函数内的函数 


## 变量提升（预解析机制）
    当浏览器去解析js的时候，会提前解析全局的变量或者函数的过程。

第一步：
    上来就找var和function

第二步：
    逐行解读代码，此时var和function就不用再去读了，一般都的是赋值、计算、输出、判断


    一个匿名函数自执行函数，如果带有名字，在函数体内不管如何赋值同名的变量，结果都等于这个有名函数

PK规则：
    变量没有函数大，后面的函数声明比前面的函数声明大（后面的函数声明会覆盖前面的函数声明）

## 闭包
    
    函数就是一个闭包，   闭包 函数可以使用函数之外定义的变量

    内部函数的作用域链仍然保持着对父函数活动对象的引用，就是闭包（closure）

    函数嵌套函数，子函数引用父函数的参数或者变量，并且子函数还被外界所引用，这个时候子函数的作用域链仍然保持着对父函数活动对象的引用，父函数的参数和变量就不会被浏览器垃圾回收机制给回收，此时打印父函数的函数返回值，会发现在返回值下面有一个scopes，这个scopes下面有个closure，他就是闭包（整个父级都形成了闭包环境）
    

    全局的活动对象在关闭浏览器只会才会被销毁


## let var const 区别

    var 变量提升，存入到全局的活动变量对象中，允许有多个同名的变量，不支持块级作用域

    let 不会变量提升且有暂存死区(在变量定义的上方都访问不到这个变量)
    不会存入到全局的活动变量对象中，
    不允许有多个同名的变量
    支持块级作用域

    const 常量
        不会变量提升且有暂存死区（在变量定义的上方都访问不到这个变量）
        不会存入到全局的活动变量对象中 
        不允许有多个同名的变量
        值是不能被改变的（引用类型可以改变属性值）
        声明了必须赋值


        解决重命名问题一（封闭空间） 也有人看到匿名函数自执行都称为闭包
        函数天生就有局部作用域，函数内的变量、函数或者参数不被外界污染就形成了一个天然的保护层，不会被全局污染

        每个引用类型的地址是不一样的，在不一样的地址下挂同名的属性访问的时候，虽然属性名一样 但是空间地址不一样，也能解决重命名的问题（命名空间）



